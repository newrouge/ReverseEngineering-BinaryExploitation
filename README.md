# ReverseEngineering-BinaryExploitation
While leraning this new skill i want to doucment everything each tool, resource, talk, book etc. refernced while i will also write my own blog to put my learning into words. 

## Day 1
*Finding from where to learn stuff found some awesome stuffs, after consuming some content evryone was talking about **Heap** & **stack**. I had rough idea but what exactly are they and how are they relevant to RE/BE?*

### Stack vs Heap

+ Each process on initiating gets its own set of stack and heap.
+ stack is assigned to simple variables(static memory allocation) while heap is for more complex objects which consist of different variables or u can say dynamic memory allocation.
+ upon completion or as soon as variable goes out of scope stack is cleared but heap remains same unless programmer deallocates memory manually, but modern programs have garbage collectors for that task.
+ They both reside in RAM(not physically) just a portion of memory which is used for doing the task.

**You should give following articles a read yourself for better understanding**

1. [stack-low-memory-vs-high-memory-address](https://stackoverflow.com/questions/50421145/stack-low-memory-vs-high-memory-address-actual-location) 

2. [Decreasing memory address in stack](https://stackoverflow.com/questions/4560720/why-does-the-stack-address-grow-towards-decreasing-memory-addresses?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa) 

3. [what and where?](https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap) 

4. [Difference-between-stack-and-heap](https://www.programmerinterview.com/data-structures/difference-between-stack-and-heap/) 

5. [Six-important-NET-concepts-Stack-heap-value-types](https://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types) 

6. [what-where-stack-heap-maxim-malisciuc](https://www.linkedin.com/pulse/what-where-stack-heap-maxim-malisciuc) 

7. [how-is-stack-and-heap-are-assigned-to-each-processes](https://softwareengineering.stackexchange.com/questions/325704/how-is-stack-and-heap-are-assigned-to-each-processes)


## Day 2
*Understading Assembly Language*

### Assembly language: 
+ Reading this [blog](https://www.intezer.com/blog/malware-analysis/malware-reverse-engineering-beginners/) 
+ What are registers these are like variables used in assembly language to store values or point to different locations in stack.
+ one thing that did hold me for few hours why every program starts & end with fixed assem. code i.e. **prologue** and **epilogue**.

#### Prologue: 
 *when a fucntion is called prologue creates the stack frame for that function, e.g when an add function is called in main function a stack frame will be created for add function*
```
push pbp
move ebp, esp
```  

#### Epilogue:
*When an function ends and need to be returned to main function it was called in. stack frame need to cleard and epilogue is responsible for that*

```
move esp, ebp
pop ebp
ret
``` 
+ when stack frame is created prologue set ESP(current stack pointer) & EBP(current base pointer), where ebp remebers the current location, one after the return address, and esp keep changing through out the function.
+ when function ends esp is reset to ebp by epilogue and pops the ebp which points the current stack pointer to return address and function successfully return to main fucntion.
+ ofcourse all of it was not so clear on simply reading the blog so i had to google and found this 3 part series watch this.

[Undersatnding prologue and epilogue](https://www.youtube.com/watch?v=5iQkR69H_1M)

+ some other discussions you might find handy
https://stackoverflow.com/questions/36046201/why-do-we-push-ebp-and-mov-ebp-esp-in-the-callee-in-assembly
https://www.varonis.com/blog/stack-memory-3#:~:text=push%20ebp%20preserves%20ESP%2C%20the,the%20base%20of%20the%20stack
https://stackoverflow.com/questions/31206192/does-the-stack-automatically-get-popped-when-leaving-a-function-in-x86-nasm-asse

+ Learned about how different things work like high meory low memory, 4 bytes difference etc. just read the blog you will get it.'
+ `push ebp` is like pushing the previous value stored in ebp register.
+ now evrything works according to prologue and epilogue, in end when point back esp to ebp and `pop ebp`. ebp stores the value which was removed which is same as 
  it got from main function.
+ Now both esp & ebp have same value it came with with all the processing done and pointers can nicely return back to their home wooh!
  [video](https://www.youtube.com/watch?v=2OPcOVzsbL8&t=212s) , [blog](https://www.cs.uaf.edu/2015/fall/cs301/lecture/09_16_stack.html#:~:text=%22pop%22%20retrieves%20the%20last%20value,code%20will%20crash%20almost%20immediately!)
  

*i hope this prologue and epilogue is clear enough now to me and u guys also, waiting to see it in action practically* .


## Day 3:
+ more assembly, ret statement is basically `ret=pop esp` so esp should be pointing to returnaddress otherwise it won't know where to go.
  
   ![Screenshot from 2022-01-30 11-28-40](https://user-images.githubusercontent.com/79413473/151689039-ee7a3a25-541b-484e-9657-b60349676063.png)
   
So when you pop from a stack, nothing is actually deleted. pop just means grab the value at the top of the stack and load it into the register specified, then increase esp to point to the new top of the stack. Example:
```
0x4 - value1      <- esp
0x8 - value2
0xC - old ebp      <- ebp
0x10 - return addr 
0x14 - param a
0x18 - param b
0x1C - value1
0x20 - value2
0x24 - old ebp
0x28 - return addr 
0x2C - param a
0x30 - param b
```  
So here you have two hypothetical stack frames. If you were to return from the top method, then the stack registers get updated to start referencing the previous stack frame, 
```
0x4 - value1
0x8 - value2
0xC - old ebp
0x10 - return addr 
0x14 - param a
0x18 - param b
0x1C - value1     <- esp
0x20 - value2
0x24 - old ebp    <- ebp
0x28 - return addr 
0x2C - param a
0x30 - param b
```  
Nothing ever gets removed from the stack, so the contents of the old stack frame stay in memory until something needs that space and overwrites it.
Another example with a similar stack frame. Say my function runs and it needs to execute pop eax with the stack in the following state.
```
0x4 - value1      <- esp
0x8 - value2
0xC - old ebp      <- ebp
0x10 - return addr 
0x14 - param a
0x18 - param b
```
Then eax would be updated to contain value1, then it would add 4 to the value of esp to point to the new top of the stack.
```
0x4 - value1
0x8 - value2      <- esp
0xC - old ebp      <- ebp
0x10 - return addr 
0x14 - param a
0x18 - param b
```
So even though address 0x8 is now the new top of the stack, if you were to explicitly access esp-0x4 you would still get value1. Now assume you have value3 in ebx and you execute a push ebx. Value3 would get put in the location of esp-0x4 and the value of esp would be adjusted accordingly. So you end up with
```
0x4 - value3      <- esp
0x8 - value2
0xC - old ebp      <- ebp
0x10 - return addr 
0x14 - param a
0x18 - param b
```
value1 no longer exists on the stack because our push operation overwrote it.
To visual a function return here are the steps:
```
mov esp, ebp
ebp = 0xC
esp = 0xC
eip = 0x? (some value)

0x4 - value1      
0x8 - value2
0xC - old ebp      <- ebp  <- esp
0x10 - return addr 
0x14 - param a
0x18 - param b
0x1C - value1
0x20 - value2
0x24 - old ebp
0x28 - return addr 
0x2C - param a
0x30 - param b
```
pop ebp (which increments esp as well)
```
ebp = 0x24
esp = 0x10
eip = 0x? (some value)

0x4 - value1      
0x8 - value2
0xC - old ebp      
0x10 - return addr <- esp
0x14 - param a
0x18 - param b
0x1C - value1
0x20 - value2
0x24 - old ebp    <-ebp
0x28 - return addr 
0x2C - param a
0x30 - param b
```
pop eip
```
ebp = 0x24
esp = 0x14
eip = return addr

0x4 - value1      
0x8 - value2
0xC - old ebp      
0x10 - return addr
0x14 - param a    <- esp
0x18 - param b
0x1C - value1
0x20 - value2
0x24 - old ebp    <-ebp
0x28 - return addr 
0x2C - param a
0x30 - param b
```
Now the calling function that we returned to will typically clean up the stack by either subtracting 8 from esp or by calling a double pop, depending on compiler optimizations. (Though different calling conventions may have slightly different ways of handling these scenarios)

Thanks to **GruntOrama** from HTB discord to explaint this. That there not actually any stack it's just for evry functions registers values get's updated and appended and when things are no longer needed they get dereferenced. It's continous process of moving back and forth.


